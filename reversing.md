# README
# Part 1 - Reverse Engineering
## Author

name: Brian C. Morris

email: bcmorri3@ncsu.edu

Unity id: bcmorri3

## Level 1
### Vulnerability:
Flag stored as string within the provided binary file.
### Description:
After downloading the binary of the source code from the server, using the strings command in a terminal on the RE_Lvl1 file shows the flag in plaintext. Some of the output of strings is provided below.

```
[bcmorri3@engr-ras-102 Level1]$ strings RE_Lvl1
/lib/ld-linux.so.2 <br>
libc.so.6 <br>
_IO_stdin_used <br>
strncmp <br>
__isoc99_scanf <br>
puts <br>
printf <br>
strlen <br>
__libc_start_main <br>
__gmon_start__ <br>
GLIBC_2.7 <br>
GLIBC_2.0 <br>
PTRh <br>
[^_] <br>
flag{85bdf179647b0d8791322a38a8729626} <br>
Agent Login: <br>
%128s <br>

...
```

## Level 2
### Vulnerability:
Flag stored as string within the provided binary file.
### Description:
After downloading the binary of the source code from the server, using the strings command in a terminal on the RE_Lvl2 file shows multiple flags in plaintext. Submitting each flag to the hw submission server indicates which flag is valid, in my case it was the first flag. Some of the output of strings is provided below.

```
[bcmorri3@engr-ras-102 Level2]$ strings RE_Lvl2
/lib/ld-linux.so.2
libc.so.6
_IO_stdin_used
srand
strncmp
__isoc99_scanf
puts
printf
strlen
__libc_start_main
__gmon_start__
GLIBC_2.7
GLIBC_2.0
PTRh0
QVh]
[^_]
flag{840a346af7ff312d9efa810cac9aae17}
flag{4de4135c6b482a8df81ef77e44baad86}
flag{3356b986a6cab58bf85b150846ca070d}
flag{7d4d2d61ed39726f6ccc9e57717c9237}
flag{13b11280a9ccb84923b92793a2264b64}
flag{ddc141b71e10e7d927c0c585c771b290}
Agent Login:
%32s
Agent Your Passcode %s

...
```

## Level 3
### Vulnerability:
The encryption algorithm is viewable after disassembly, visible to a program such as IDA.
### Description:
After opening the provided RE_Lv3 with IDA, observing the EncodeEngine subroutine reveals the encryption algorithm. Each character of the provided input file is encoded byte-by-byte by adding XOR'ing the byte with 0x13 (19) and adding 0x11 (17). Writing a simple decryption script in python (provided in the RE repository), I was able to decrypt the provided message.enc file, revealing the flag. The output of this is provided below.

```
[bcmorri3@engr-ras-201 Level3]$ python decrypt.py
Agent, the password is "flag{a38f3a95c32ccf92240ace5cd7f66624}"
```

## Level 4
### Vulnerability:
Binary file can be patched to change a ```cmp``` instruction, resulting in a ```jz``` instruction not being executed.
### Description:
After opening the provided RE_Lv4 with IDA, in the main subroutine, I saw a ```cmp``` and ```jnz``` instruction pair at the bottom of the first branch. By highlighting the hex value in the ```cmp eax,0DEADBEEFh``` instruction, and then clicking the hex-view tab at the top, I was able to observe the location of 0DEADBEEFh in the binary file. I changed the EF to 12, and then clicked Edit -> Patch Program -> Apply patches to input file... -> Take defaults, applied the changes to the provided binary file. Running the patched RE_Lv4 file and inputting an arbitrary password, when prompted, revealed the flag. Output is provided below.

```
[bcmorri3@engr-ras-201 Level4]$ ./RE_Lvl4
Agent Login: no cmp for u
Welcome Agent Id: flag{eub1qaja74b4xcnlt7e9n7du2os2qi7f}
```

## Level 5
### Vulnerability:
Memory address of ```jnz``` can be seen by inspection with IDA, and can be avoided by overwriting pc register with GDB. 
### Description:
After opening the provided RE_Lv5 with IDA, in the main subroutine (in the lower right-most set of branches) I saw the instruction: ```jnz     short loc_8048981```, jumping to the invalid output. By clicking the line ```mov     dword ptr [esp], 2CDh``` in the valid outut, I was able to see the memory address in the subroutine on the bottom bar of IDA showing me its memory address was: 0x8048963, indicating the memory address location I needed to be at to execute the printout of the flag. Using GDB, I was able to change the pc register to the memory address, and retrieve the flag. The following input/outut from GDB was used to retrieve the flag.

```
[bcmorri3@engr-ras-201 Level5]$ gdb RE_Lvl5
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /afs/unity.ncsu.edu/users/b/bcmorri3/CSC405/hw3/ReverseEngineering/Level5/RE_Lvl5...(no debugging symbols found)...done.
(gdb) break main
Breakpoint 1 at 0x8048780
(gdb) run
Starting program: /afs/unity.ncsu.edu/users/b/bcmorri3/CSC405/hw3/ReverseEngineering/Level5/RE_Lvl5

Breakpoint 1, 0x08048780 in main ()
Missing separate debuginfos, use: debuginfo-install glibc-2.17-222.el7.i686
(gdb) set $pc = 0x8048963
(gdb) n
Single stepping until exit from function main,
which has no line number information.
Welcome Agent flag{o17vz2at4ytzl5vmcappdsn7kn0sbbia}
0x0804b008 in ?? ()
(gdb)
```

## Level 6
### Vulnerability:
Memory address of ```jnz``` can be seen by inspection with IDA, and can be taken by overwriting pc register with GDB. 
### Description:
After opening the provided RE_Lv5 with IDA, in the main subroutine (in the lower right-most set of branches) I saw the instruction: ```jnz     short loc_804895D```, jumping to the valid output. By changing the pc register with GDB to jump to that valid memory location, I was able to retrieve the flag. The following input/outut from GDB was used to retrieve the flag.

```
[bcmorri3@engr-ras-201 Level6]$ gdb RE_Lvl6
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /afs/unity.ncsu.edu/users/b/bcmorri3/CSC405/hw3/ReverseEngineering/Level6/RE_Lvl6...(no debugging symbols found)...done.
(gdb) break main
Breakpoint 1 at 0x80488f7
(gdb) run
Starting program: /afs/unity.ncsu.edu/users/b/bcmorri3/CSC405/hw3/ReverseEngineering/Level6/RE_Lvl6

Breakpoint 1, 0x080488f7 in main ()
Missing separate debuginfos, use: debuginfo-install glibc-2.17-222.el7.i686
(gdb) set $pc = 0x804895d
(gdb) n
Single stepping until exit from function main,
which has no line number information.
Success! flag{417nbznovwki881wezmtglhkl1elq1n5}
0x0804b008 in ?? ()
(gdb)
```
